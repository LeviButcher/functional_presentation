{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"2e2a705c-8ee0-5ee7-82d8-23c4f4e15e5d","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar themes = [future];\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar SitePadding = makeShortcode(\"SitePadding\");\nvar layoutProps = {\n  themes: themes,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h1\", null, mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Functional Programming\")), mdx(\"p\", null, \"By: Levi Butcher\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/LeviButcher/functional_presentation\"\n  }), \"Github With Source Code\")), mdx(\"p\", null, \"Presentation hosted at: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://i-love-functions.netlify.com\"\n  }), \"https://i-love-functions.netlify.com\"))), mdx(\"hr\", null), mdx(\"h4\", null, \"Object-Oriented\"), mdx(\"p\", null, \"Use Objects that can do whatever they want\"), mdx(\"h4\", null, \"Functional\"), mdx(\"p\", null, \"Only write Pure Functions\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h3\", null, \"Pure Function\"), mdx(\"p\", null, \"A Pure Function is a function that given the same input, you will always get the same output, \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"without Side Effects\")), mdx(\"p\", null, \"f(5) -> 10\"), mdx(\"p\", null, \"f(6) -> 12\"), mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"f(5) -> 5 Violating Pure Functions\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Side Effects\"), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"p\", null, \"A \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Side Effect\"), \" is the result of something else changing outside of the scope of the function you are calling.\")), mdx(\"p\", null, \"Examples of Side Effects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Global Data being set\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Anything Dealing with I/O\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Calling databases\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Throwing Errors\")), mdx(\"p\", null, \"If your method is returning void, it is impure.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"A Java Pure Function\"), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"class Calculator {\\n  public static int add(int a, int b) {\\n      return a + b;\\n  }\\n}\\nmain() {\\n    int result = Calculator.add(5,2);\\n    result == 7;\\n}\"), mdx(\"hr\", null), mdx(\"h3\", null, \"The Benifits of Pure Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Easy to \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Reason About\"), \" your program\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Highly Composable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Super easy to test (Haskell writes them for you)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can cache the output and never call the function again\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Completely Thread safe\")), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"That's it\"), mdx(\"p\", null, \"Functional Programming is programming with a set of hard requirements (aka Pure Functions).\"), mdx(\"p\", null, \"However, the combination of Pure Functions with some Functional Programming Concepts leads to amazing results.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"First Class Functions\"), mdx(\"p\", null, \"Functions are \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"First Class\"), \", if we can store a function into a variable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"var add = Calculator::add;\\nadd(5, 2);\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Function Composition\"), mdx(\"p\", null, \"We can \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"combine\"), \" functions to make new functions\"), mdx(\"p\", null, \"f(x) = 5x;\\ng(x) = x/5;\"), mdx(\"p\", null, \"f(g) == (x/5) \", \"*\", \" 5\"), mdx(\"p\", null, \"y = f(g);\"), mdx(\"p\", null, \"result = y(1)\"), mdx(\"p\", null, \"result == 5\"), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"public static int divideByFive(int a) {\\n    return a / 5;\\n}\\npublic static int multiplyByFive(int a) {\\n    return a * 5;\\n}\\npublic static\\n<A, B, C>\\nFunction<A, C> compose(Function<A, B> g, Function<B, C> f) {\\n    return (x) -> f.apply(g.apply(x));\\n}\\nvar multiplyThenDivide = compose(divideByFive, multipleByFive);\\nmultiplyThenDivide(1) == 5\"), mdx(\"hr\", null), mdx(\"p\", null, \"We can do better then that... With the power of \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Currying\")), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"public int divide(int a, int b) {\\n    return a / b;\\n}\\npublic int multiply(int a, int b) {\\n    return a * b;\\n}\\npublic static\\n<A, B, C> Function<B, C> curry(BiFunction<A, B, C> f, A arg) {\\n    return (x) -> f.apply(arg, x);\\n}\\nvar multiplyByFive = curry(Calculator::multiply, 5);\\nvar divideByFive = curry(Calculator::divide, 5);\\nvar divideByFiveThenMultiplyByFive =\\ncompose(divideByFive, multiplyByFive);\\nmultiplyByFiveThenDivideByFive(5)\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Higher Order Functions\"), mdx(\"p\", null, \"A \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Higher Order Function\"), \" is a function that takes in another function as a arguement.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"compose\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"curry\"), \" are examples of higher order functions\")), mdx(\"hr\", null), mdx(\"h2\", null, \"The Sacred Tools of FP\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"map\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"reduce (fold)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"filter\")), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Reduce (also known as fold)\"), mdx(\"p\", null, \"Reduce \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"combines\"), \" a list into a single result using the function provided with the help of a identity value\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => B\\nB reduce(A identityValue, BiFunction<A, B> func,\\n    List<A> list)\\n\\nvar listOfInts = List.of(4, 5);\\nvar sumOfList =\\n  reduce(0, a -> a + b, listOfInts)\\n\\n sumOfList -> 5\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => B\\npublic static <A, B> B reduce(B identityValue,\\n  BiFunction<B, A, B> f, List<A> list) {\\n  if(list.isEmpty()) {\\n      return identityValue;\\n  }\\n  var result =  f.apply(identityValue, list.get(0));\\n  return reduce(result, f, list.subList(1, list.size()));\\n}\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Map\"), mdx(\"p\", null, \"Returns a \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"new list\"), \", turning every element inside of list into a type B using the function provided\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => [B]\\nList<B> map(Function<A, B> func, List<A> list);\\n\\nvar listOfInts = List.of(4, 5);\\nvar listOfStrings = map(a -> a.toString(), listOfInts);\\n\\n// listOfStrings -> [\\\"4\\\", \\\"5\\\"]\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => [B]\\npublic static <A, B> List<B> map(Function<A,B> f, List<A> list) {\\n  return reduce(List.of(), (acc, curr) -> {\\n      // This would be much easier\\n      // if java's List api abide by pure functions\\n      var result = f.apply(curr);\\n      return Stream.of(\\n              List.of(result).stream(),\\n              acc.stream()\\n      ).flatMap(i -> i).collect(Collectors.toList());\\n  }, list);\\n}\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Filter\"), mdx(\"p\", null, \"Returns a new list of A, that is a list of all elements that \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"returned true\"), \" from the passed in function\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => [A]\\nList<A> filter(Function<A, Boolean> func, List<A> list)\\n\\nvar listOfInts = List.of(1,0,1,0,1,0);\\nvar only1s = filter(a -> a == 1, listOfInts);\\n\\n// only1s -> [1,1,1]\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => [A]\\npublic static <A>\\nList<A> filter(Function<A, Boolean> f, List<A> list) {\\n    return reduce(List.of(), (acc, curr) -> {\\n        var shouldReturn = f.apply(curr);\\n        if(shouldReturn) {\\n            return Stream.of(\\n                    acc.stream(),\\n                    List.of(curr).stream()\\n            ).flatMap(i -> i).collect(Collectors.toList());\\n        }\\n        return acc;\\n    }, list);\\n}\\n\"), mdx(\"hr\", null), mdx(SitePadding, {\n    mdxType: \"SitePadding\"\n  }, mdx(\"h3\", null, \"Alright, but I don't really see the benifits here\")), mdx(\"hr\", null), mdx(\"div\", {\n    style: {\n      \"padding\": \"2rem\"\n    }\n  }, mdx(\"h1\", null, \"Challenge\"), mdx(\"p\", null, \"You have been given a list of strings that represent the run-time of various satellites. If the satellite was offline, then the value will be a empty string.\"), mdx(\"p\", null, \"Compute the average run-time of the satellites that are online, while also reporting how many satellites are offline.\"), mdx(\"p\", null, \"Satelite Data: \", \"[\\\"48\\\", \\\"20\\\" , \\\"\\\", \\\"100\\\", \\\"18\\\", \\\"47\\\", \\\"\\\", \\\"\\\", \\\"\\\"]\")), mdx(\"hr\", null), mdx(\"p\", null, \"Inside Challenge.java\"), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"var expectedAverage = 46;\\nvar expectedOfflineCount = 4;\\n// Start\\nvar onlineSat = filter(x -> !x.isEmpty(), satelliteData);\\nvar onlineSatNumbers = map(Integer::valueOf, onlineSat);\\nvar offlineSatCount =\\n  filter(String::isEmpty, satelliteData).size();\\nvar onlineLength = onlineSat.size();\\nvar onlineAverage =\\n  reduce(0, Calculator::add, onlineSatNumbers) / onlineLength;\\n// End\\nassertEquals(expectedAverage, onlineAverage);\\nassertEquals(expectedOfflineCount, offlineSatCount);\"), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"var expectedAverage = 46;\\nvar expectedOfflineCount = 4;\\n// Start\\nvar sumOfSatellites = 0;\\nvar offlineSatCount = 0;\\nvar satelliteSize = 0;\\nfor (var ele : satelliteData) {\\n    if(ele.isEmpty()) {\\n        offlineSatCount++;\\n    }\\n    else {\\n            var eleNumber = Integer.parseInt(ele);\\n            sumOfSatellites += eleNumber;\\n            satelliteSize++;\\n    }\\n}\\nvar onlineAverage = sumOfSatellites / satelliteSize;\\n// End\\nassertEquals(expectedAverage, onlineAverage);\\nassertEquals(expectedOfflineCount, offlineSatCount);\"), mdx(\"hr\", null), mdx(\"h2\", null, \"The stuff I didn't Cover\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Immutability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Referential Transparency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Functors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monads\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monoids\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Algebraic Data Types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tail-Recursion\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Laziness\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parallelization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memoization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Closures\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Good Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://soundcloud.com/lambda-cast\"\n  }), \"Lambda Cast\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\"\n  }), \"FunFunFunction\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/MostlyAdequate/mostly-adequate-guide\"\n  }), \"Mostly Adequate Guide to FP in Javascript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://learnyouahaskell.com/\"\n  }), \"Learn you a Haskell\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://corecursive.com/\"\n  }), \"CoRecursive\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","id":"2e2a705c-8ee0-5ee7-82d8-23c4f4e15e5d","slug":"","title":"Pure Function"}}}