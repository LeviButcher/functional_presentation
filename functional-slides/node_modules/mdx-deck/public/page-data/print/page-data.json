{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","result":{"data":{"deck":{"id":"2e2a705c-8ee0-5ee7-82d8-23c4f4e15e5d","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar themes = [future];\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  themes: themes,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Functional Programming\"), mdx(\"p\", null, \"By: Levi Butcher\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/LeviButcher/functional_presentation\"\n  }), \"Github With Source Code\")), mdx(\"hr\", null), mdx(\"h3\", null, \"The Evolution of Languages\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Procedural - the birth of functions\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Object Oriented - global data is bad, lets group functions and data together\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functional - Only use Pure Functions\"))), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h3\", null, \"Pure Function\"), mdx(\"p\", null, \"A Pure Function is a function that given the same input, you will always get the same output, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"without Side Effects\"))), mdx(\"p\", null, \"f(5) -> 10\"), mdx(\"p\", null, \"f(6) -> 12\"), mdx(\"p\", null, \"f(5) -> 5 Violating Pure Functions\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Side Effects\"), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"p\", null, \"A \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Side Effect\"), \" is the result of something else changing outside of the scope of the function you are calling.\")), mdx(\"p\", null, \"Examples of Side Effects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Global Data being set\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Anything Dealing with I/O\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Calling databases\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Throwing Errors\")), mdx(\"p\", null, \"If your method is returning void, it has side effects.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"A Java Pure Function\"), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"\\n  class Calculator {\\n    public static int add(int a, int b) {\\n        return a + b;\\n    }\\n  }\\n  main() {\\n      int result = Calculator.add(5,2);\\n      result == 7;\\n  }\\n  \"), mdx(\"hr\", null), mdx(\"h3\", null, \"The Benifits of Pure Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Easy to \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Reason About\"), \" your program\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Highly Composable, No coupling\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Super easy to test (Haskell writes them for you)\")), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"That's it\"), mdx(\"p\", null, \"Functional Programming is programming with a set of hard requirements (aka Pure Functions).\"), mdx(\"p\", null, \"However, the combination of Pure Functions with some Functional Programming Concepts leads to amazing results.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"First Class Functions\"), mdx(\"p\", null, \"Functions are \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"First Class\"), \", if we can store a function into a variable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"var add = Calculator::add;\\nadd(5, 2);\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Function Composition\"), mdx(\"p\", null, \"We can combine functions to make new functions\"), mdx(\"p\", null, \"f(x) = 5x;\\ng(x) = x/5;\"), mdx(\"p\", null, \"f(g) == (x/5) \", \"*\", \" 5\"), mdx(\"p\", null, \"y = f(g);\"), mdx(\"p\", null, \"result = y(1)\"), mdx(\"p\", null, \"result == 5\"), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"\\n    public static int divideByFive(int a) {\\n        return a / 5;\\n    }\\n    public static int multiplyByFive(int a) {\\n        return a * 5;\\n    }\\n    public static <A, B, C> Function<A, C> compose(Function<A, B> g, Function<B, C> f) {\\n        return (x) -> f.apply(g.apply(x));\\n    }\\n    var multiplyThenDivide = compose(divideByFive, multipleByFive);\\n    multiplyThenDivide(1) == 5\\n  \"), mdx(\"hr\", null), mdx(\"p\", null, \"We can do better then that... With the power of \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Currying\")), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"\\n    public int divide(int a, int b) {\\n        return a / b;\\n    }\\n    public int multiply(int a, int b) {\\n        return a * b;\\n    }\\n    public static <A, B, C> Function<B, C> curry(BiFunction<A, B, C> f, A arg) {\\n        return (x) -> f.apply(arg, x);\\n    }\\n    var multiplyByFive = FunctionalUtils.curry(Calculator::multiply, 5);\\n    var divideByFive = FunctionalUtils.curry(Calculator::divide, 5);\\n    var divideByFiveThenMultiplyByFive = compose(divideByFive, multiplyByFive);\\n    multiplyByFiveThenDivideByFive(5)\\n  \"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Higher Order Functions\"), mdx(\"p\", null, \"A \", mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Higher Order Function\"), \" is a function that takes in another function as a arguement.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"compose\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"curry\"), \" are examples of higher order functions\")), mdx(\"hr\", null), mdx(\"h2\", null, \"The Sacred Tools of FP\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"map\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"reduce (fold)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"filter\")), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Reduce (also known as fold)\"), mdx(\"p\", null, \"Reduce combines a list into a single result using the function provided with the help of a identity value\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => B\\nB reduce(A identityValue, BiFunction<A, B> func, List<A> list)\\n\\n// This version uses the two first elements of list\\nB reduce(BiFunction<A, B, B> func, List<A> list)\\n\\nsumOfList = listOfInts.reduce(0, a -> a + b, listOfInts)\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => B\\npublic static <A, B> B reduce(B identityValue,\\n  BiFunction<B, A, B> f, List<A> list) {\\n  if(list.isEmpty()) {\\n      return identityValue;\\n  }\\n  var result =  f.apply(identityValue, list.get(0));\\n  return reduce(result, f, list.subList(1, list.size()));\\n}\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Map\"), mdx(\"p\", null, \"Returns a new list, turning every element inside of list into a type B using the function provided\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => [B]\\nList<B> map(Function<A, B> func, List<A> list);\\n\\nlistOfStrings = map(a -> a.toString(), listOfInts);\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => [B]\\npublic static <A, B> List<B> map(Function<A,B> f, List<A> list) {\\n  return reduce(List.of(), (acc, curr) -> {\\n      // This would be much easier if java's List api abide by pure functions\\n      var result = f.apply(curr);\\n      return Stream.of(\\n              List.of(result).stream(),\\n              acc.stream()\\n      ).flatMap(i -> i).collect(Collectors.toList());\\n  }, list);\\n}\\n\"), mdx(\"hr\", null), mdx(SlidePadding, {\n    mdxType: \"SlidePadding\"\n  }, mdx(\"h2\", null, \"Filter\"), mdx(\"p\", null, \"Returns a new list of A, that is a list of all elements that returned true from the passed in function\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"// [A] => [A]\\nList<A> filter(Function<A, Boolean> func, List<A> list)\\n\\nonly1s = filter(a -> a == 1, listOfInts);\\n\"))), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"// [A] => [A]\\npublic static <A> List<A> filter(Function<A, Boolean> f, List<A> list) {\\n    return reduce(List.of(), (acc, curr) -> {\\n        var shouldReturn = f.apply(curr);\\n        if(shouldReturn) {\\n            return Stream.of(\\n                    acc.stream(),\\n                    List.of(curr).stream()\\n            ).flatMap(i -> i).collect(Collectors.toList());\\n        }\\n        return acc;\\n    }, list);\\n}\\n\"), mdx(\"hr\", null), mdx(\"h3\", null, \"Alright, but I don't really see the benifits here\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Challenge\"), mdx(\"p\", null, \"You have been given a list of strings that represent the run-time of various satellites. If the satellite was offline, then the value will be a empty string.\"), mdx(\"p\", null, \"Compute the average run-time of the satellites that are online, while also reporting how many satellites are offline.\"), mdx(\"p\", null, \"Satelite Data: \", \"[\\\"48\\\", \\\"20\\\" , \\\"\\\", \\\"100\\\", \\\"18\\\", \\\"47\\\", \\\"\\\", \\\"\\\", \\\"\\\"]\"), mdx(\"hr\", null), mdx(\"p\", null, \"Inside Challenge.java\"), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"var expectedAverage = 46;\\n  var expectedOfflineCount = 4;\\n  // Start\\n  var onlineSat = FunctionalUtils.filter(x -> !x.isEmpty(), satelliteData);\\n  var onlineSatNumbers = FunctionalUtils.map(Integer::valueOf, onlineSat);\\n  var offlineSatCount =\\n    FunctionalUtils.filter(String::isEmpty, satelliteData).size();\\n  var onlineLength = onlineSat.size();\\n  var onlineAverage =\\n    FunctionalUtils.reduce(0, Calculator::add, onlineSatNumbers) / onlineLength;\\n  // End\\n  assertEquals(expectedAverage, onlineAverage);\\n  assertEquals(expectedOfflineCount, offlineSatCount);\"), mdx(\"hr\", null), mdx(SyntaxHighlighter, {\n    language: \"java\",\n    style: atomDark,\n    mdxType: \"SyntaxHighlighter\"\n  }, \"var expectedAverage = 46;\\n  var expectedOfflineCount = 4;\\n  // Start\\n  var sumOfSatellites = 0;\\n  var offlineSatCount = 0;\\n  var satelliteSize = 0;\\n  for (var ele : satelliteData) {\\n      if(ele.isEmpty()) {\\n          offlineSatCount++;\\n      }\\n      else {\\n              var eleNumber = Integer.parseInt(ele);\\n              sumOfSatellites += eleNumber;\\n              satelliteSize++;\\n      }\\n  }\\n  var onlineAverage = sumOfSatellites / satelliteSize;\\n  // End\\n  assertEquals(expectedAverage, onlineAverage);\\n  assertEquals(expectedOfflineCount, offlineSatCount);\"), mdx(\"hr\", null), mdx(\"h2\", null, \"The stuff I didn't Cover\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Immutability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Referential Transparency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Functors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monads\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monoids\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Algebraic Data Types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tail-Recursion\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Laziness\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parallelization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Memoization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Closures\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Good Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://soundcloud.com/lambda-cast\"\n  }), \"Lambda Cast\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\"\n  }), \"FunFunFunction\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/MostlyAdequate/mostly-adequate-guide\"\n  }), \"Mostly Adequate Guide to FP in Javascript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://learnyouahaskell.com/\"\n  }), \"Learn you a Haskell\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://corecursive.com/\"\n  }), \"CoRecursive\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2e2a705c-8ee0-5ee7-82d8-23c4f4e15e5d","slug":"","title":"Functional Programming"}}}